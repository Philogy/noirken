{
  "name": "PrivateCounter",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "initial_count",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 120
          },
          "visibility": "private"
        },
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+2dd3gcxRnGRzoVW5IbxXL3uXf5TidZJ2xAYGyCsQ3GEJJQJeskBJLOSGdsmd5777333nsCpHfSewKkd9K7yb7m20fDckn+8Ls8eR+Y5xl/p93z7u+3ezs7uzs7ky1xblaQkRBKg1xmn8O/yyN/V0T+Hh3kTe6tyRbpWixmUosaGnJN9bl0Jt2aqm9uyzamGhrbFmXT2XRjtrG9PpvJ5LIN2abmtuamVHO6IZNLdzQ2ZzpSb6Yx3rJS25ji5BwrwjlOhHO8COcEEc6JIpyTRDgni3AmRTiniHBOFeGcJsI5XYRzhgjnTBHOWSKcs0U454hwzhXhnCfCOV+Ec4EIZ50I50IRzpQIZ1qEs16EMyPC2SDC2UjkBBvu5SVtebiPtyXItRbHWBxrcZzF8RYnWJxocZLFyRaTFqdYnGpxmsXpFmdYnGlxlsXZFudYnGtxnsX5FhdYrLO40GLKYtpivcWMxQaLjd7yFgW5yb15zxOp1GI4Pc59m3Uav8FmEc6dRDgXi3AuEeHcWYRzFxHOXUU4W0Q4dxPh3F2Ec6kI5x4inMtEOJc7fl14pC0P9T3UCbMWmy3uZHGxxSUWd7a4i8VdLbZY3M3i7haXWtzD4jKLy91gXXTPIL/PDT5/D+ui4fQ4t+1evG2bDrdtyL+Xe+t1BtKKIO9trqXed8PpCc/xv3mnti2lVzjubypMK73PZRZLvWkJixUxOLnIeqLbcXiRadSVx7GTVsaw3FWOdwDF5b2Kv49iLaRXETkTRTiRVnufh1qsiGE7xXBwplDglUfYkcLCAQfnEItInbnCfq297fme5V257vaSIv/D3xKJyLyh3udwXqWL8fAPy/5wZdF7TKvd4DlgnyDva5sj4YGG06PnkRX2f/fxlrEmyPvZMsq874bTEx6Ln/7fzyOJmHlHO35xwmasFWBcHQNjHJxrXDz1nLXe5xqLKHSidR6/cCrxpkULsRiK8UxcxfgQz8NFfMNifJT93ZsvdHUMLO3LtRZy7avzhZy/EcPzQaLIgvzCwJ9f5q28IrIcf8OG82It9f1lsn+5ax23QvFOXFUwS64SjzH8Aewf5AOC/H7PYZh7+84Pk1LlqMLzCJN/VGF+GXe9Gb90ct72dkW2m/PWjyM8LPWCitq+G9q6u9btnRsots8SRZbrl47RQsDfj+G8WA/isGZa7EcWrdZh3habv8W+gzgiyAcG+QO2LL/6Fk53RTZAi8VtvfogHnjpAx234Cl3b0/sgqfUaVRHmNXlODn3F+E8wHFPOO9dfrz7Lj/8k1ZYLn8wyB9yg2m8Rb/W6ddEi53E3g2XAlWeh4v4hpcC4aOGXE9XYVnvur6B9cGlwMp8p39Cr7RYXmQ5/nZFKvM+l3vbsyLy3QqPq4XjXD/UDV7+OG/dfmrxPvt36aq4LFuPrWpvXSFXuJ5qb36lx1HN5dh666sq4u8zxLTerf41/8O/pghHzTvo798aqIpw+sd+OC/2im6l+8+FnHP82+IHOf7JJA7Og0U4DxHhPFSE8zARzsNFOFtFONtEONeJcLaLcOZEODtEODtFOI8Q4ewS4TxShPMoEc5uEc4eEc5eEc68COd6Ec6jRTj7RDj7RTgLIpwbRDiPEeHcKMK5SYRzQIRzswjnsSKcx4lwHi/CeYII54kinCeJcJ4swnmKCOepIpyniXCeLsJ5hgjnmSKcZ4lwni3CeY4I57kinOeJcJ4vwnmBCOeFIpwXiXBeLMJ5iQjnpSKcl4lwXi7CeYUI55UinFeJcF4twnmNCOe1IpzXiXBeL8J5gwjnjSKcN4lw3izCeYsI560inLeJcN4uwnmHCOedIpx3iXDeLcJ5jwjnvSKc94lw3i/C+YAI54MinA+JcD4swvmICOejIpyPiXA+LsL5hAjnkyKcT4lwPi3C+YwI57MinM+JcD4fE2dphDO1bWlrpxAs5w+LOJcSnT8i4pwgOr8g4lxGdH5RxLmc6PySiHMF0fmjIs57Ep0/JuJ8ENH54yLOBxOdPyHifAjR+ZMizocSnT8l4nwY0fnTIs6HE50/I+LcSnT+rIhzG9H5cyLO64jOnxdxbic6f0HEOUd0/qKIcwfR+WUR506i85dEnI8gOn9ZxLmL6PwVEecjic5fFXE+iuj8NRHnbqLz10Wce4jO3xBx7iU6f1PEOU90/paI83qi87dFnI8mOn9HxLmP6PxdEed+ovP3RJwLROfvizhvIDr/QMT5GKLzKyLOG4nOr4o4byI6vybiPEB0/qGI82ai849EnI8lOv9YxPk4ovNPRJyPJzr/VMT5BKLzz0Sc1xCdfy7ifCLR+RcizicRnX8p4nwy0flXIs6nEJ1/LeJ8KtH5NyLOpxGdfyvifDrR+XUR5zOIzr8TcT6T6Px7EeeziM5/EHE+m+j8RxHnc4jOfxJxPpfo/GcR5/OIzn8RcT6f6PxXEecLiM5/E3G+kOj8dxHni4jO/xBxvpjo/E8R50uIzv8Scb6U6LxFxPkyovMbIs6XE53RWYCC8xVE5xIR5yuJzqUizlcRnRMizlcTnctEnK8hOpeLOF9LdK4Qcb6O6Fwp4nw90XmIiPMNROehIs43Ep2rRJxvIjpXizjfTHSuEXG+heg8TMT5VqLzcBHn24jOI0Scbyc6jxRxvoPoPErE+U6i83YizncRnbcXcb6b6LyDiPM9ROcdRZzvJTqPFnG+j+hcK+J8P9F5jIjzA0TnsSLODxKdx4k4P0R0Hi/i/DDReYKI8yNE54kizo8SnSeJOD9GdJ4s4vw40Tkp4vwE0XmKiPOTROepIs5PEZ2niTg/TXSeLuL8DNF5hojzs0TnmSLOzxGdZ4k4P090ni3iXEl0niPiPIToPFfEeSjReZ6IcxXReb6IczXReYGIcw3RuU7EeRjReaGI83Cic0rEeQTROS3iPJLoXC/iPIronBFx3o7o3CDivD3RuVHEeQei8yIR5x2Jzk1E51pbTok5Y0xIjJGIMQMxhh6uB3F9hOsF1J9Rn0T9CvUNnH9xPkL5jPIKxy9+z9i/8B0d5Fpvm262iDFBMUbmC0F+McgvBRlj7GHMOYzBhjHJMEYXxqzCGE4Y0whj/GDMG4wBgzFRMEbIy0HGGBIYUwFjDKDPffRBjz7Z0Uc5+uxGH9bo0xl9HKPPX/SBiz5h0UfqK0F+NcivBRl9LKLPQfTBhz7p0Ecb+ixDH17o0wp9PKHPI/QBhD5x0EfM60FGHyLoUwN9TKDPBfRBgHfy8Y463tnGO8x4pxfvuOKdT7wDiXcC37CNjneo8E4R3rHBOyd4BwPvJKCNPtqsow032jSjjS/avKINKNpEoo0g2syhDRnaVKGNEdrcoA0K2mSgjQKe2eMZNp7p4hknnvnhGRieCeEZCZ4Z4B467injHivuOeIeHO5J4R4N7lngGh7XtLjGwzUPrgFQJ0YdEXUm1CFwTsU5BmUuyiAck/iNlnj7frHFJRbXFvJ9rZ25ZH93vpBMJXuDf1u7u/Mbc+11SX9ef7JnQ38h2V9o7SskO/ryPcl03b8BtpHQHRDzAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_counter",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+2dCZgdVZ32+3bnJqmuzt6dfense9JdnX292QkhQAgQAgQSIIR9DTsYEBAREREREVEWARERFVERFVAQkXHU0RmXUREBZ5x935dvzs3/pV8OlWv6o4798nDO8yT9r7dunfd3llvnVN269zTU1dWV6vamBoo5QavY37Y3l9pLxeXVxrz1FF8zZu/fxNNd6klxpSCOnsXXU1uZWJOccva1/T2K9c2cV0NdXW4f8OutjvwdS7lYlrakrrMOGsinV7E+1T7p9wtswyslhnJAljTHO4BPlnhldqlWO8PfHdebuPA3KbgeSuSDfHsTg0tcV+WALGmOdwCfLPHK7FKtNknob6PF3DZpwfVQIh/ki+2U/oKhHJAlzfEO4JMlXpldqtUmzNJULEv1fNjH8mokn74F122JfJAvtvtSOcHQFJAlzfEO4JMlXpldqtXO8HfH9bO4D/H1L7geSuSDfLENL66rpoAsaY53AJ8s8crsUq02gb87boDF/YhvYMH1UCIf5ItteHFdNQVkSXO8A/hkiVdml2q1CfzdcYMsHkB8zQXXQ4l8kC+24cV1VQ7IkuZ4B/DJEq/MLtVqE/i741osHkR8gwuuhxL5IF9sw4vrqhyQJc3xDuCTJV6ZXarVJvB3xw2xuIX4hhZcDyXyQb7YhhfXVTkgS5rjHcAnS7wyu1SrTeDvjhtm8RDiG15wPZTIB/liG15cV+WALGmOdwCfLPHK7FKtNoG/O26ExcOIb2TB9VAiH+SLbXhxXZUDsqQ53gF8ssQrs0u12gT+7rhRFo8gvtEF10OJfJAvtuHFdVUOyJLmeAfwyRKvzC7VahP4u+Psduhrxzu+1oLroUQ+yBfb8OK6KgdkSXO8A/hkXLdItdqk1f6648ZaPIb4xhVcDyXyQb7YhhfXVTkgS5rjHcAnS7wyu1SrTeDvjhtv8Vjim1BwPZTIB/liG15cV+WALGmOdwCfLPHK7FKtNoG/O26ixeOJb1LB9VAiH+SLbXhxXZUDsqQ53gF8ssQrs0u12gT+7rjJFk8kvikF10OJfJAvtuHFdVUOyJLmeAfwyRKvzC7VahP4u+OmWjyZ+KYVXA8l8kG+2IYX11U5IEua4x3AJ0u8MrtUq02YZUaxLHMcy/QusMwglpnFsrS5PGaRF7jgk9J+7geziuWo9smZXvmxzXyR9e3NmpA2tZtZ+Nw1PRzLnDTHO4BPlnhldqnWeYnbZLbFM4mvrVi+apvM9liwDS+uq3JAljTHO4BPlnhldqlWmzBLVihLR/Vz6/YusGTE0lEoy95xaw55gQs+Ke3nfjCnWI5qn+zwyo9t5ouskTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja/GsCWmzu5mFnyVpD8bS0ZbmeAcoc5Z4ZXap1nMi3CZzLe4gvnnF8lXbZK7Hgm14cV2VA7KkOd4BfLLEK7NLtdqEWRYUypJVnyOa3wWWBcSysFCWvc8RLSIvcMEnpf3cDxYVy1Htkwu98mOb+SJrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayR9a3CmpA2t5tZ+F78/GAsWfVzGN87QJmzxCuzS7Xus3ObLLZ4IfEtKZav2iaLPRZsw4vrqhyQJc3xDuCTJV6ZXarVJsyyrFiW6u+QLO0CyzJiWV4sS5vvBS74pLSf+0GlWI5qn1zuld8va2SNrAlpi7uZhc9dS8OxVH+HxPcO4JNx3SLVOi8hdsetsHg58a0slq/aJis8f2zDi+uqHJAlzfEO4JMlXpldqtUmzLK6UJb26vMDq7rAsppY1hTKsnfcWkte4IJPSvu5H6wtlqPaJ9d45cc280XWyBpZI2tkjayRNbJG1rc3a0Laim5m4WuZVcFY2qv3X33vAGXOEq/MLtW6TuE2WWfxGuI7oFi+apus81iwDS+uq3JAljTHO4BPlnhldqlWmzDLgYWy7L2OXd8FlgOJZUOhLHuvYw8iL3DBJ6X93A8OKpaj2ic3eOXHNvNF1sgaWSNrZI2skTWyRta3N2tC2rpuZuFrmfXBWPZex/reAcqcJV6ZXap1ncJtstHiDcR3cLF81TbZ6LFgG15cV+WALGmOdwCfLPHK7FKtNmGWQwOwHNIFlkOJZVOxLNXr2MPIC1zwSWk/94PDiuWo9slNXvmxzXxvFdaEtI3dzMLvsUPCsWRpjncIn8Qrs0u13j/cJpst3kR8hxfLV22TzR4LtuHFdVUOyJLmeAfwyRKvzC7VahNmOTIAyxFdYDmSWLYUy1I9vx5FXuCCT0r7uR8cVSxHtU9u8cqPbeZ7q7AmpG3uZhZ+jx0RjqV6fvW9Q/gkXpldqvX+4TbZavEW4ju6WL5qm2z1WLANL66rckCWNMc7gE+WeGV2qVabwN8dd4zFW4nv2ILroUQ+yBfb8OK6KgdkSXO8A/hkiVdml2q1CfzdcdssPob4jiu4Hkrkg3yxDS+uq3JAljTHO4BPlnhldqlWm8DfHXe8xduIb3vB9VAiH+SLbXhxXZUDsqQ53gF8Mq5bpFptst3+uuN2WHw88Z1QcD2UyAf5YhteXFflgCxpjncAnyzxyuxSrTaBvzvuRIt3EN9JBddDiXyQL7bhxXVVDsiS5ngH8MkSr8wu1WoT+Lvjdlp8IvGdXHA9lMgH+WIbXlxX5YAsaY53AJ8s8crsUq02gb87bpfFO4nvlILroUQ+yBfb8OK6KgdkSXO8A/hkiVdml2q1CfzdcadavIv4Tiu4Hkrkg3yxDS+uq3JAljTHO4BPlnhldqlWm8DfHXe6xacS3xkF10OJfJAvtuHFdVUOyJLmeAfwyRKvzC7VahP4u+POtPh04jur4HookQ/yxTa8uK7KAVnSHO8APlnildmlWm0Cf3fc2RafSXznFFwPJfJBvtiGF9dVOSBLmuMdwCdLvDK7VKtN4O+OO9fis4nvvILroUQ+yBfb8OK6KgdkSXO8A/hkiVdml2q1CfzdcedbfC7x7S64Hkrkg3yxDS+uq6aALGmOdwCfLPHK7FKtNoG/O+4Ci88nvgsLrocS+SBfbMOL66opIEua4x3AJ0u8MrtUq03g7467yOILiO/iguuhRD7IF9vw4rpqCsiS5ngH8MkSr8wu1WoT+LvjLrH4IuK7tOB6KJEP8sU2vLiuygFZ0hzvAD5Z4pXZpVptAn933GUWX0J8lxdcDyXyQb7YhhfXVTkgS5rjHcAnS7wyu1SrTeDvjrvC4suI7x0F10OJfJAvtuHFdVUOyJLmeAfwyRKvzC7VahP4u+P2WHwF8V1ZcD2UyAf5YhteXFflgCxpjncAn4zrFqlWm1xpf91xV1m8h/jeWXA9lMgH+WIbXlxX5YAsaY53AJ8s8crsUq02gb877mqLryK+awquhxL5IF9sw4vrqhyQJc3xDuCTJV6ZXarVJvB3x11r8dXE966C66FEPsgX2/DiuioHZElzvAP4ZIlXZpdqtQn83XHXWXwt8b274HookQ/yxTa8uK7KAVnSHO8APlnildmlWm0Cf3fc9RZfR3zvKbgeSuSDfLENL66rckCWNMc7gE+WeGV2qVabwN8dd4PF1xPfewuuhxL5IF9sw4vrqhyQJc3xDuCTJV6ZXarVJvB3x91o8Q3E976C66FEPsgX2/DiuioHZElzvAP4ZIlXZpdqtQn83XE3WXwj8b2/4HookQ/yxTa8uK7KAVnSHO8APlnildmlWm0Cf3fczRbfRHwfKLgeSuSDfLENL66rckCWNMc7gE+WeGV2qVabwN8dd4vFNxPfBwuuhxL5IF9sw4vrqhyQJc3xDuCTJV6ZXarVJvB3x91q8S3E96GC66FEPsgX2/DiuioHZElzvAP4ZIlXZpdqtQn83XG3WXwr8X244HookQ/yxTa8uK7KAVnSHO8APlnildmlWm3CLB8plqX6m/+3d4HlI8RyR7Es1e+SfZS8wAWflPZzP/hosRzVPnmHV35sM19kfXuzJqTd1s0sfO66PRxL9Tf/fe8APlnildmlWuclbpM7Lb6D+D5WLF+1Te70WLANL66rckCWNMc7gE+WeGV2qVabMMtdhbJk1d9K/HgXWO4ilrsLZdk7bt1DXuCCT0r7uR/cUyxHtU/e7ZUf28wXWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjaxvFdaEtDu7mYXvxX88GEtW/a1v3ztAmbPEK7NLJW+7QjG3yb0W3018nyiWr9om93os2IYX11U5IEua4x3AJ0u8MrtUq02Y5f5CWfauWXVfF1juJ5YHCmXZ+znMJ8kLXPBJaT/3g08Wy1Htkw945cc280XWyBpZI2tkjayRNbJG1rc3a0Lavd3Mwtcy9wVj2btmle8doMxZ4pXZpVrXKdwmD1r8APF9qli+aps86LFgG15cV+WALGmOdwCfLPHK7FKtNmGWTxfKsvc69qEusHyaWB4ulGXvdexnyAtc8ElpP/eDzxTLUe2TD3vlxzbzRdbIGlkja2SNrJE1skbWtzdrQtqD3czC1zIPBWPZex3rewcoc5Z4ZXap1nUKt8kjFuN4x/dZiyv2t+3NpWqbPEL+FdqGF9dVOSBLmuMdwCdLvDK7VKtNmOXzhbLsvY79XBdYPk8sjxbKsvc69gvkBS74pLSf+8EXiuWo9slHvfJjm/kia2SNrJE1skbWyBpZI+vbmzUh7ZFuZuFrmc8FY9l7Het7ByhzlnhldqnWdQq3yWMWP0p8XyyWr9omj3ks2IYX11U5IEua4x3AJ0u8MrtUq02Y5cvFslR/l+xLXWD5MrE8XixL9Tr2K+QFLviktJ/7wVeK5aj2yce98mOb+SLr25s1Ie2xbmbhc9eXwrFUf5fM9w7gkyVemV2qdV7iNnnC4seJ76vF8lXb5AmPBdvw4roqB2RJc7wD+GSJV2aXarUJs3y9WJbquPW1LrB8nVieLJalOm49RV7ggk9K+7kfPFUsR7VPPumVH9tPkR5Z396sCWlPdDMLn7u+Fo6lOm753gF8Mq5bpFrnpafsrzvuaYufJL5vFMtXbZOnPRZsw4vrqhyQJc3xDuCTJV6ZXarVJszyTACWb3aB5RliebZYluq49S3yAhd8UtrP/eBbxXJU++SzXvmxzXxvFdaEtKe7mYXfY98Mx5KlOd4hfBKvzC7Vev9wmzxn8bPE9+1i+apt8pzHgm14cV2VA7KkOd4BfLLEK7NLtdoE/u645y1+jvi+U3A9lMgH+WIbXlxX5YAsaY53AJ8s8crsUq02gb877gWLnye+Pyi4Hkrkg3yxDS+uq3JAljTHO4BPlnhldqlWm8DfHfddi18gvj8suB5K5IN8sQ0vrqtyQJY0xzuAT5Z4ZXapVpvA3x33PYu/S3zfL7geSuSDfLENL66rckCWNMc7gE+WeGV2qVabwN8d9wOLv0d8f1RwPZTIB/liG15cV+WALGmOdwCfLPHK7FKtNoG/O+6HFv+A+H5UcD2UyAf5YhteXFflgCxpjncAnyzxyuxSrTaBvzvujy3+IfH9ScH1UCIf5ItteHFdlQOypDneAXyyxCuzS7XahFl+XCxLm8vzJwXXo8vjp8SPsoI9pf0/obL9tGCOEnkiX2wz3/6y1ncza6j2/1mxeVb7N9epS7X698+ofH9aMEvT/+XRq66zXZG/X7f1xPMLirEf553G//v385zXIe5B+/lc9WKx5ar2l19aXiX796LH4nx/FcD3RSofc8CrgV7zSs+9f/sEqYcsc3m+VGyeHS7PXxeb5xyX58vF5jnX5flKsXnOc3m+Wmye89O6znR+XWff/E2hPnv7JqcKxfBill1CLMcIsWwQYlkoxPJdIZbJQixPCrGMEGJ5WIilnxDLHUIsNwqxXCXEcoEQy6lCLNuEWDYKsSwWYvmeEMtUIZanhVhGCbE8IsQyQIjlTiGWBiGWm4RYrhZiuUiI5XQhluOFWDYJsSwXYvmBEMtMIZZnhVjGCLE8KsQySIjlbiGWnkIsNwuxXCvEcokQy5lCLDuEWDYLsawQYvmhEMtsIZbnhFjGCrE8JsTSIsRyrxBLbyGWW4RYrhNiuUyI5WwhlhOFWLYIsawRYukQYnleiGW8EMvjQixDhFgeEGJpFGK5VYjleiGWK4RYzhVi2SnEslWIZZ0Qy8+FWOYKsbwgxDJRiOUJIZZhQiwPCrH0EWK5TYjlBiGWPUIspW5mSere+L2phPY3kfZnFp9O2p9bfCZpv7X4bNL+wuJzSftLi88n7a8svoC0v7b4ItL+xuJLSPtbiy8j7e8svoK0v7d4D2n/YPFVpP2jxVeT9k8WX0vaP1t8HWn/YvH1pP2rxTeQ9m8W30jav1t8E2n/YfHNpP2nxbeQ9l8W30raf1t8G2n/Y/EdpP2vxXeShs5xN2kl0+4lrd60B0hrMO1B0nqY9jBpZdMeIa2naY+S1su0x0jrbdrjpCWmPUFao2lPkpaa9jRpTaY9S1of054jra9pz5PWz7QXSOtv2ndJG2Da90gbaNoPSBtk2g9JazaN35ctpjWQNti0nqQNMa03aUNNayRtmGl9SBtuWj/SRpg2gLSRpg0ibZRpLaSNNm0IaWNMG0Zaq2kjSBtr2ijSxpk2hrTxpo0lbYJp40mbaNpE0iaZNpm0yaZNJW2KaTNJm2rabNKmmdZB2nTT5pI2w7SFpM00bTFps0xbTtps01aQ1mbaGtIwMKwjLTNtA2kdpm0kbY5pm0iba9pm0uaZtoW0+aZtJW2BaceQttC0baQtMu140habtoO0JaadSNpS03aStsy0XaQtN+1U0iqm/Zy0Faa9SNpK014ibZVpvyZttWkvk7bGtFdIW2vaq6TVW8xjN97zf0ZaD4v/nDR8T/i3pOHc8Bek9bL4L0nD+eKvSEss/mvScA75G9Iw1/lb0nDu+jvScK75e9L6WvwPpOH884+k9bf4n0jDOemfSRto8b+QhvPUv5LWbPG/kYZz17+TNtji/yAN57P/JG2oxf9FGs5x/03acIv/hzSc9/6XtJEWY2yunmMhkTbatHrScH5sIK3VtB6kjTWtTNo403qShvNoL9ImmNabtNfOraRNMq2RNJxvU9KmmNZE2lTT+pA2zbS+pE03rR9pM0zrTxrO3wNIm2XaQNJwTh9EWptpzaS1m9ZCWmbaYNIwHgwhbY5pQ0nDGDGMtHmmDSdtvmkjSFtg2kjSML6MIm2RaaNJw5gzhrQlprWSttS0saQtM20caRivxpNWMW0CaStMm0jaStMmkbbKtMmkrTZtCmkY/6aStta0aaRhTJxO2gGmzSBtvWkzSTvQtFmkYTydTdpBprWRhjG2nbSDTctIO8S0DtIONW0OaRif55J2mGnzSMOYPZ+0w01bQNoRpi0k7UjTFpGG8X4xaUeZtoQ0zAGWkna0actIw7xgOWnHmlYhDXOFFaQdZ9pK0jB/WEXadtNWk7bDtDWknWAaxmY3pn4/6dyP12Kc5nGc80Fsf6rjMLwrprW9uVTtRuxToW14NRID9nUnyx4hlhuEWG4TYukjxPKgEMswIZYnhFgmCrG8IMQyV4jl50Is64RYtgqx7BRiOVeI5QohluuFWG4VYmkUYnlAiGWIEMvjQizjhVieF2LpEGJZI8SyRYjlRCGWs4VYLhNiuU6I5RYhlt5CLPcKsbQIsTwmxDJWiOU5IZbZQiw/FGJZIcSyWYhlhxDLmUIslwixXCvEcrMQS08hlruFWAYJsTwqxDJGiOVZIZaZQiw/EGJZLsSySYjleCGW04VYLhJiuVqI5SYhlgYhljuFWAYIsTwixDJKiOVpIZapQizfE2JZLMSyUYhlmxDLqUIsFwixXCXEcqMQyx1CLP2EWB4WYhkhxPKkEMtkIZbvCrEsFGLZIMRyjBDLLiGW8z0W/j7lWtLq615/bC/jxrMZlWK42/h3HODpfE4q1qfm7zjAa19rHnQ3y0Ihlg4hlplCLJOFWMYKsRwnxDJCiOUoIZYWIZbDhFj6CbEcJMSSCLGsFWJpEGKpCLEsEmKZI8QyS4hlihDLOCGW44VYRgqxbBViGSzEslmIpb8Qy0YhlkYhlnVCLD2EWFYIsSwWYpkrxDJbiGWqEMt4IZbtQiyjhFiOFmIZIsRyuBDLACGWg4VYUiGWA4RYykIsK4VYlgixzBNiaRNimSbEMkGIZYcQy2ghlmOEWIYKsRwhxDJQiOUQIZYmIZb1Qiw9hVhWCbEsFWKZL8TSLsQyXYhlohDLCUIsY4RYjhViGSbEcqQQyyAhlkOFWPoIsRwoxNJLiGW1EMsyIZYFQiyZEMsMIZZJQiytQizbhFiGC7FsEWJpFmLZJMTSV4hlgxBLbyGWNUIspW5mSery17TF/nrS8Lv6vHbmyRb3IA3fgyuTdgqVExq+196LtNMs5nU3T6cYf8+wmNfixO/xpaSdZTGvAYrf+uU1O8+xuC9p+O1+XsfzPIv7k4bv2vHanrstHkgavjvP631eaHEzafhdHl4D9GKLB5OG3/zjdUEvtXgoafg9YV4r9HKLh5OG9QF4/dB3WDySNKw9xGuKXmnxaNKuspjXGX2nxa2k4bd/xpJ2jcXjSMPvCvJ6pO+yeAJp+M1iXqP03RZPIu16i3nd0vdYPIW0GyyeStp7LZ5GGn4DYDpp77N4Bmn4fSFeB/X9Fs8iDb9dyGujfsDiNtLwu8jtpH3Q4ow0rHPA66p+yOI5pGENJV5r9cMWzyPtdovnk/YRixeQht8j4HVaP2rxItLw+0K8duvHLF5C2sctXkraXRYvI+1ui3nd13ssrpCG309eQdonLF5J2n0WryLtfotXk/baugmkfdLitaQ9aDGvLfspiw8g7SGL15P2aYsPJA2/b7CBtM9YfBBp+L0iXqv2sxYfTNrnLD6EtM9bfChp+M1EXuf2CxYfRhp+j5nXvv2ixYeT9iWLjyDtyxYfSRrWYeB1c79i8VGkYY0nXkv3qxYfTdrXLOb1db9u8bGk4fcSeM3dpyw+jrSnLeZ1eL9h8XbSvmnxDtKesfgE0vAbjLxeL8ZnHs8xPvMavhifTyYN4zOv64vx+RTSMD6fShrG59NIw/jM4zXG5zNIw/h8JmkYn88iDePz2aRhfD6HNIzP55KG8fk80jA+n08axufdpGF8voA0jM8Xkobx+SLSMD5fTBrG50tIw/h8KWkYny8jDePz5aRhfL6CNIzP7yAN4/Me0jA+X0kaxuerSGu1+J2kYXy+mjSMz9eQhvH5WtIwPr+LNIzP15GG8fndpGF8vp40jM/vIW2qxTeQhvH5vaRhfL6RNIzP7yMN4/NNpGF8fj9pGJ9vJg3j8wdIw/h8C2kYnz9IGsbnW0nD+Pwh0jA+30YaxucPk4bx+XbSMD5/hDSMz3eQhvH5o6RhfL6TNIzPHyMN4/PHScP4fBdpGJ/vJq1i8T2kYXy+lzSMz58gDePzfaRhfL6fNIzPD5CG8fmTpGF8fpA0jM+fIm29xQ+RhvH506RhfH6YNIzPnyEN4/MjpGF8/ixpGJ8/RxrG58+ThvH5UdIwPn+BNIzPj5GG8fmLpGF8/hJpGJ+/TBrG58dJw/j8FdIwPj9BGsbnr5KG8flrpGF8/jppGJ+fJA3j81OkYXx+mrTtFn+DNIzP3yQN4/MzpGF8xnjtxtnfNnXux2v52vrZnHwQ8z0CeFfsb9ubS9V7BOxToW148dq3zwiwrBFi6S3EskGIpa8QyyYhlmYhli1CLMOFWLYJsbQKsUwSYpkhxJIJsSwQYlkmxLJaiKWXEMuBQix9hFgOFWIZJMRypBDLMCGWY4VYxgixnCDEMlGIZboQS7sQy3whlqVCLKuEWHoKsawXYmkSYjlEiGWgEMsRQixDhViOEWIZLcSyQ4hlghDLNCGWNiGWeUIsS4RYVgqxlIVYDhBiSYVYDhZiGSDEcrgQyxAhlqOFWEYJsWwXYhkvxDJViGW2EMtcIZbFQiwrhFh6CLGsE2JpFGLZKMTSX4hlsxDLYCGWrUIsI4VYjhdiGSfEMkWIZZYQyxwhlkVCLBUhlgYhlrVCLIkQy0FCLP2EWA4TYmkRYjlKiGWEEMtxQixjhVgmC7HMFGLpEGJZKMSyXIil3mPh73A/S1q9dyzW1j65WO7MeeG73nXEz6lC8clUh7uKZWlzLPju+E7yObVYn2pbneKVD9vwSolhV0CWNMc7gE+WeGV2qVY7M8vpAVhO6wLL6cRyZgCWM7rAciaxnB2A5awusJxNLOcGYDmnCyznEsv5AVjO6wLL+cRyQbEsCx3L7i6wXEAsFxbL0ubyvKjgPF0eFxM/ygr2lPZfRGW7uFiO6jn6wrrX1ym2Lw7nWy3/Jb+j/JfkcFzyeyw/8+0v6663EOtFbyHW2AfCsMY+EIa1u/tAQtop3czCc+/d4VgWpr+jHk4TqAcwhOwfefUQor4Tr8wu1ZqjMculxbJU5xOXkRe4LqW6x34+511WcN2XyBP5Ypv59pf14m5mDeBbbavLf0f5L8/huPz3WH7m21/Wi95CrBe/hVhjHwjDGvvA/rMmpJ3RzSwpMVwYjqU6n6pVD2cJ1AMYdgVkyauHAHOYHQnlfw75XBGgbi/36hbbV1DdguHSgCxpjjfXw3kC9QCGE3/P9RDAZ2HildmlWnN2ZnlHsSzVeeAe8gLXO6jusZ/H1T0F132JPJEvtplvf1kvfgux7noLscY+EIY19oEwrLEP7D9rAN/qWMe+LtUa65jlymJZqmPdVeQFLviktJ/7+FXFclTb4kqv/Nhmvv1lvfgtxHrZW4g19oEwrLEPhGGNfWD/WXltuXpiuTIAS53HUpdTL0jLhVh2CrEsFGLpEGKZKcQyWYhlrBDLcUIsI4RYjhJiaRFiOUyIpZ8Qy0FCLIkQy1ohlgYhlooQyyIhljlCLLOEWKYIsYwTYjleiGWkEMtWIZbBQiybhVj6C7FsFGJpFGJZJ8TSQ4hlhRDLYiGWuUIss4VYpgqxjBdi2S7EMkqI5WghliFCLIcLsQwQYjlYiCUVYjlAiKUsxLJSiGWJEMs8IZY2IZZpQiwThFh2CLGMFmI5RohlqBDLEUIsA4VYDhFiaRJiWS/E0lOIZZUQy1IhlvlCLO1CLNOFWCYKsZwgxDJGiOVYIZZhQixHCrEMEmI5VIiljxDLgUIsvYRYVguxnCTEskyIZYEQSybEMkOIZZIQy4lCLK1CLNuEWIYLsWwRYmkWYtkkxNJXiGWDEEtvIZY1QiylbmZJ6t74He6E9teTdpXFDaS90+IepF1tcZm0a6ic0K61uBdp77K4N2nXUYy/77a4kbTrLU5Je4/FTaTdYHEf0t5rcV/SbrS4H2nvs7g/aTdZPIC091s8kLSbLR5E2gcsbibtFotbSPugxYNJu9XiIaR9yOKhpN1m8TDSPmzxcNJut3gEaR+xeCRpd1g8irSPWjyatDstHkPaxyxuJe3jFo8l7S6Lx5F2t8XjSbvH4gmk3WvxRNI+YfEk0u6zeDJp91s8hbQHLJ5K2ictnkbagxZPJ+1TFs8g7SGLZ5L2aYtnkfawxbNJ+4zFbaQ9YnE7aZ+1OCPtcxZ3kPZ5i+eQ9qjFc0n7gsXzSHvM4vmkfdHiBaR9yeKFpH3Z4kWkPW7xYtK+YvES0p6weClpX7V4GWlfs3g5aV+3uELakxavIO0pi1eS9rTFq0j7hsWrScPaJ2tIe8bitaRh3ZR1pH3L4gNIe87i9aR92+IDSXve4g2kfcfig0h7weKNpP2BxQeT9l2LDyHtDy0+lLTvWbyJtO9bfBhpP7B4M2l/ZPHhpP3Q4iNI+5HFR5L2xxZvIe1PLD6KtB9bvJW0n1h8NGk/tfgY0n5m8bGk/anF20j7ucXHkfYLi48n7ZcWbyftRYt3kPYri08g7SWL+bcDf23xLtJetvgdpL2S87pXLb6UtN9YfCJpmANcSRrmAFeRhjnAO0nDHOBq0jAHuIY0zAGuJQ1zgHeRhjkAzwkwB3g3aZgDXE8a5gDvIQ1zgBtIwxzgvaRhDnAjaZgDvI80zAFuIg1zgPeThjnAzaRhDvAB0jAHuIU0zAE+SBrmALeShjnAh0jDHOA20jAH+DBpmAPcThrmAB8hDXOAO0jDHOCjpGEOcCdprRZ/jDTMAT5OGuYAd5GGOcDdpGEOcA9pmAPcSxrmAJ8gDXOA+0jDHOB+0qZa/ABpmAN8kjTMAR4kDXOAT5GGOcBDpGEO8GnSMAd4mDTMAT5DGuYAj5CGOcBnScMc4HOkYQ7wedIwB3iUNMwBvkAa5gCPkYY5wBdJwxzgS6RhDvBl0jAHeJw0zAG+QhrmAE+QhjnAV0nDHOBrpFUs/jppmAM8SRrmAE+RhjnA06RhDvAN0jAH+CZpmAM8QxrmALyWGuYA3yJtvcXPkYY5wLdJwxzgedIwB/gOaZgDvEAa5gB/QBrmAN8lDXOAPyQNc4DvkYY5wPdJwxzgB6RhDvBHpGEO8EPSMAf4EWmYA/wxaZgD/AlpmAP8mDTMAX5CGuYAPyUNc4CfkYY5wJ+ShjnAz0nDHOAXpG23+JekYQ7wImmYA/yKNIzPL5GGz2V+TRp+9+Vl0k62+BXSMC94lTSsMYE5gRvLT2ru3I/X8j2C3+Tkg5jvdcC7Yn/b3lyq3utgnwptw6uRGF4VYFkjxNJbiGWDEEtfIZZNQizNQixbhFiGC7FsE2JpFWI5UYhlkhDLDCGWTIhlgRDLMiGWk4RYVgux9BJiOVCIpY8Qy6FCLIOEWI4UYhkmxHKsEMsYIZYThFgmCrFMF2JpF2KZL8SyVIhllRBLTyGW9UIsTUIshwixDBRiOUKIZagQyzFCLKOFWHYIsUwQYpkmxNImxDJPiGWJEMtKIZayEMsBQiypEMvBQiwDhFgOF2IZIsRytBDLKCGW7UIs44VYpgqxzBZimSvEsliIZYUQSw8hlnVCLI1CLBuFWPoLsWwWYhksxLJViGWkEMvxQizjhFimCLHMEmKZI8SySIilIsTSIMSyVoglEWI5SIilnxDLYUIsLUIsRwmxjBBiOU6IZawQy2QhlplCLB1CLAuFWHYKsSwXYqkPz9LG3x1E3j0c14Bgnjtcni8VXA5Xj/ieo0t7qFwvUf2F8P215/uK51vy2nAPseLYBnrNhubOdkiCtUPHyXV1r6+z39hf7oNgejmHs++ATs51zZ3H4DumO6nMpxTK3rbD1emuTvS61rrO7/bAy/XtUy3Ga/n3t+qJ77Ri+Wr+/tZpOSwLhVhmCrGMFWI5SoilRYjlICGWRIilIsQyR4hlihDL8UIsI4VYNgux9BdiWSfE0kOIZbEQy2whlvFCLEcLsQwRYjlYiCUVYlkpxDJPiGWaEMsOIZbRQixHCLEMFGJZL8TSU4hlqRBLuxDLRCGWY4VYhgmxnCzEcqgQSx8hlpOEWFYLsSwQYpkhxNIqxLJFiKVZiGWDEEtvIZadQizLhVg6hFgmC7EcJ8QyQojlVCGWw4RY+gmxrBViaRBiWSTEMkuIZZwQy1YhlsFCLBuFWBqFWFYIscwVYpkqxLJdiGWUEMvhQiwDhFgOEGIpC7EsEWJpE2KZIMRyjBDLUCGWQ4RYmoRYVgmxzBdimS7EcoIQyxghliOFWAYJsRwoxNJLiGWZEEsmxDJJiGWbEMtwIZZNQix9hVjWCLGUupklIYY60rC/nrTTLW4g7QyLe5B2psVl0s6ickI72+JepJ1jcW/SzqUYf8+zuJG08y1OSdttcRNpF1jch7QLLe5L2kUW9yPtYov7k3aJxQNIw3rgA0m7zOJBpGEd8mbSrrC4hTSsQz6YtD0WDyHtSouHknaVxcNIe6fFw0nD+uIjSLvG4pGkXWvxKNLeZfFo0rC++BjSsL54K2nXWzyWtPdYPI60GyweTxrWF59AGtYXn0ga1hefRBrWF59MGtYXn0Ia1hefShrWF59GGtYXn04a1hefQRrWF59JGtYXn0Ua1hefTRrWF28jDeuLt5OG9cUz0rC+eAdpWF98DmlYX3wuaVhffB5pWF98Pml3WbyAtLstXkjaPRYvIg3riy8m7RMWLyHtPouXkna/xctIw/riy0nD+uIV0h60eAVpn7J4JWkPWbyKNKwvvpo0rC++hjSsL76WNKwvvo40rC9+AGlYX3w9aVhf/EDSsL74BtKwvvhBpGF98Y2kYX3xg0nD+uKHkIb1xQ8lDeuLbyIN64sfRhrWF99MGtYXP5w0rC9+BGlYX/xI0rC++BbSnrL4KNKetngrad+w+GjSsL74MaQ9Y/GxpD1r8TbSvmXxcaRhffHjScP64ttJe97iHaR9x+ITSHvB4lNJw/jM4znG59NJw/h8BmkYn88kDePzWaRhfD6bNIzP55CG8ZnHa4zP55GG8fl80jA+7yYN4/MFpGF8vpA0jM8XkYbx+WLSMD5fQhrG50tJw/h8GWkYny8nDePzFaRhfH4HaRif95CG8flK0jA+X0Uaxud3kobx+WrSMD5fQxrG52tJw/j8LtIwPl9HWqvF7yYN4/P1pGF8fg9pGJ9vIA3j83tJw/h8I2kYn99HGsbnm0jD+Px+0qZafDNpGJ8/QBrG51tIw/j8QdIwPt9KGsbnD5GG8fk20jA+f5g0jM+3k4bx+SOkYXy+gzSMzx8lDePznaRhfP4YaRifP04axue7SMP4fDdpGJ/vIQ3j872kYXz+BGkYn+8jDePz/aRhfH6AtIrFnyQN4/ODpGF8/hRpGJ8fIg3j86dJw/j8MGkYnz9DGsbnR0jD+PxZ0tZb/DnSMD5/njSMz4+ShvH5C6RhfH6MNIzPXyQN4/OXSMP4/GXSMD4/ThrG56+QhvH5CdIwPn+VNIzPXyMN4/PXScP4/CRpGJ+fIg3j89OkYXz+BmkYn79JGsbnZ0jD+PwsaRifv0UaxufnSNtu8bdJw/j8PGkYn79DGn4/B+O1G2d/29S5H6/la+sXcvJBzPcI4F2xv21vLlXvEbBPhbbh1UgM3xFgWSPE0leIZZMQy3Ahlm1CLJOEWDIhlmVCLL2EWA4UYhkkxHKkEMsYIZYThFimC7HMF2JZJcTSJMRyiBDLUCGWY4RYJgixtAmxLBFiKQuxHCDEMkCI5XAhllFCLNuFWKYKscwVYlkhxNIoxLJRiGWwEMtWIZZxQiyzhFgWCbE0CLGsFWLpJ8RymBDLqUIsI4RYjhNimSzE0iHEslyIZacQS28hlg1CLM1CLFuEWFqFWGYIsSwQYlktxHKSEEsfIZZDhVhOFmIZJsRyrBDLRCGWdiGWpUIsPYVY1guxDBRiOUKIZbQQyw4hlmlCLPOEWFYKsaRCLAcLsQwRYjlaiGW8EMtsIZbFQiw9hFjWCbH0F2LZLMQyUojleCGWKUIsc4RYKkIsiRDLQUIsLUIsRwmxjBVimSnEslCIpd5j4f0u4T4nvgPozgH43iGvAfJcAP5vE0eFtuGVEsPzAVnSHG8371vX3FmPJ3t14uppl1eHTkN9Y18vY36lWObqVwpetbycJz5TgI9Lv6b4N/YXx7gyvey9roG0Tc2d9bCd6uFVrx560jGVAsv2Sk7ZXibPl4r1bOd6YP+XSHux7o31+Wuqz1/lvI5j1B1e5/rLLy3m+vxFwWUrkQ/yxTa8+L32YkCWNMeb+1iA90o7171L/nslIe1VYioN6KwbpHqqm1ML5izVvT5VKIbXvtZF6m6WhUIsHUIsM4VYJguxnCTEMlaI5TghlhFCLEcJsbQIsRwmxNJPiOUgIZZEiGWtEEuDEEtFiGWREMscIZZZQixThFh2CrGME2I5XohlpBDLViGWwUIsm4VY+guxbBRiaRRiWSfE0kOIZYUQy2IhlrlCLLOFWKYKsZwsxDJeiGW7EMsoIZajhViGCLEcLsQyQIjlYCGWVIjlACGWshDLSiGWJUIs84RY2oRYpgmx7BJimSDEskOIZbQQyzFCLEOFWI4QYhkoxHKIEEuTEMt6IZaeQiyrhFiWCrHMF2JpF2KZLsRyihDLRCGWE4RYxgixHCvEMkyI5UghlkFCLIcKsfQRYjlQiKWXEMtqIZZlQiwLhFgyIZYZQiyThFhOFGJpFWLZJsQyXIhlixBLsxDLJiGWvkIsG4RYeguxrBFiKXUzS0IMdaRhP68/f5rFvP786Rbz+vNY653Xn8da79tJw1rvO0jDWu8nkIa13k8kDWu9n0Qa1nrn72ljrfeTScNa77tIw1rvp5BWbzHXFb63cBppeP7udNLwOTKve4/7obzuPeb1vO493iu87n1iMa97j+ched179C1e9x73p3nde1xn8br3OHehLlwZ/mVw5368tp6OuSAnH8Tct+Fdsb9tby5V+zb7VGgbXo3EsFuAZY0QS28hlg1CLH2FWDYJsTQLsWwRYhkuxLJNiKVViOVEIZZJQiwzhFgyIZYFQizLhFhWC7H0EmI5UIiljxDLoUIsg4RYjhRiGSbEcqwQyxghlhOEWCYKsZwixDJdiKVdiGW+EMtSIZZVQiw9hVjWC7E0CbEcIsQyUIjlCCGWoUIsxwixjBZi2SHEMkGIZZcQyzQhljYhlnlCLEuEWFYKsZSFWA4QYkmFWA4WYhkgxHK4EMsQIZajhVhGCbFsF2IZL8RyshDLVCGW2UIsc4VYFguxrBBi6SHEsk6IpVGIZaMQS38hls1CLIOFWLYKsYwUYjleiGWcEMtOIZYpQiyzhFjmCLEsEmKpCLE0CLGsFWJJhFgOEmLpJ8RymBBLixDLUUIsI4RYjhNiGSvEcpIQy2QhlplCLB1CLAuFWJYLsdR7LPw90wtIq/eOdc+s72s90X4BysKpQjG89vUbht3Nkgix9BRiaRBi6SPE0ijE0kuIpYcQS18hllSIpbcQS1mIpdTNLPv6XQzej7/43KGRtAFemZyG52abSKvP8cV5vj9peC8PIA3thXzd9uaRnfubTa+nY3D92kAaPh/oQdoQyhMa/y62X6Zm0sDYQhrKMpg0lHkIaYMsHprjy30Cx1Tsb9ubS9U+wT4V2oYX/57EUAGWshBLbyGWVIilrxBLDyGWXkIsjUIsfYRYGoRYegqxJEIsTUIs9TksgwtlmTOP5yZ1xMSpQjGvMdtSKEtbm8uzueA8XR7DiB9lBXtK+5upbMOK5ai2eUvd6+sU28PC+VbLP/x3lH94Dsfw32P5mS+yRtbI2r2szW8h1tgHImtkjazxnBVZI2tkjeesWK+RNbJG1jCs8ZwVWSNrZI3nrFivkTWyRtYwrPGcFVkja2SN56xYr5E1skbWMKzxnBVZI2tkjeesWK+RNbJG1v1nLd73pDmJ5+tSre8jMMuIQln2Pjs/krzABZ+U9nNbjCyWo9oWI7zyY5v5ImtkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJE1skbWyBpZI2tkjayRNbJG1sgaWSNrZI2skTWyRtbIGlkja2SNrJH1rcKa0v56YhkRgKXOY6nLqRekAUIsg4RY+gix9BJi6SHE0k+IZaAQS08hlgYhlv5CLH2FWHoLsZSFWErdzJIQQx1p2F9PGuYZDaSNsrgHaaMtLpM2hsoJrdXiXqSNtbg3aeMsHkjaeIsHkDbB4v6kTbS4H2mTLB5E2mSL+5A2xeK+pE21eAhp0yxuIQ31xvWMehtJGuptFGmot9Gkod7GkIZ6ayUN9TaWtMTicaQ1WjyeNPTLCaQ1WTyRNNTRJNJQR5NJQ51PIQ1tM5U0tCHq0ZX/kVGd+/Fa7ovTcvJBzO8peFfsb9ubS9X3FPtUaBtejcQwVYClLMTSW4ilrxBLfyGWBiGWnkIsA4VY+gmx9BBi6SXE0keIZZAQywAhlnqPJaH900ir947tZdxJsdwZz+HqiJ9TheKE6rCxWJY2nhPy9VtTsT7Vtkq98mEbXikxNAZkSXO8A/hkiVdml2q1M7P0LZalg+f0+8PC9xX6FcvS5vLoT17ggk9K+7kf9C+Wo9on+3nlxzbzRdbiWROPqztZ+HzQJxxLR5rjHcAnS7wyu1Trvc4sAwsuM1/77w8L3/8eVCxLm8uzueA8XR4txI+ygj2l/c1UtpZiOar9fFDd6+sU28wXWYtnTUjr180sfI4ZEI6lei7Lq4eeXpu468YPjOzkKHr+6uqE5zV7iIHHuBC+TZ5vg+frXsPzqD3EimMb6DVrRnXW2e1UZ32KZc/4Xm4dsXKqUNwnXD128P3n/WHhNi34uqwtwFhcHR94/ENZwZ7Sfh6HBxTLUT13JHWvr1NsM19kLZ6VP5/p280sKTE0hWOpjg++dwCfLPHK7FKt8wezFDy/rJ7LBnaBhZ9TKnpeGmDMr57LBhM/ygr2lPa3UNkGF8tR7efNda+vU2wzX2QtnjUhLelmFj7HDAzHUj2X+d4h3rP8eT/Pn79Pc8Gi5yd581gwBLxHUfVt9HzLni/P7TF/BiuObaDX/NnIzjr78cjO12E/31vme87QkGc/0sDSlzQe1/EX/Y+fLcH5necmzZQPNLyn+d4Y+hl74fMJfkYG1xz8nAs+q+P3Keo271oNXvi8I8R98K7ce+b6Qj0FvC/X7vfFCm3zPUIw9AjHsjDN8Q51j5DL7NL+3CPk+3l8LVbwfcNqmwzwWLANL66rckCWNMc7gE9bXpl75fgWfV+0VPf6eWuF6hNefO+p5z7aI9Q9L5zHyh4HvBroNfV2D6VPXZi5QB17Ufvw/G0oxf652PXXId7rHOewguvN54D/MNJG5HAOJc7h3usCfOcl8znAyd/HGZ3DOYI4R3mvc/0Bddyf7qmtGNV5DPLn6/GC26B6Pchlc6nWOZa/WzSkWJbqe5znrhXyYN8Q79/BVPYSeUBvoLgVjVn3+vv/aC8wuzYcmvM6jkd4x/BnBkMDl3kIcVRoG16uP7ZQWYfmcPcibuzHe9L1LbQb9+GhAcoyzCvLMI+Z7ymNCMdSvQ7zvRtJ4+vRgt8/1fcyt5FLtd7LQ4il6PswPCbivdyS41vwPOF1YzHey/CAzmPxAurf/LkV2gvMrg0H57yOY/+9zp8/DQ5cZj6nVGgbXu69PJPKmjcX4Pcy9vP3Afi7BihLiHsq+zov5d1TGRqOpfpe9r15jA7x3JfLg69D0SZ8vQmNr/W+L/hZHH9uxuf/gj+fa/fvD1Xq3ngPhs//9eFYqtfGvncAn+z/9zNJ/iyCP1sJcb9iX5/z8P0K/ow5FEua4x3qfqFf5p45vgV/vlT17e/5oj7hxdftPffRHqHGJlx7lz0OeDXQa7Z718YF37+uXhvDq77ujc+CuMRjo38/072P/GuDAHO5dp8D/jw2DsvhHEycQ73XOc7hxXJmPgc4h5M2ModzGHH6vx/h+gPq+Cy6Nn6Iro2RP98bR578jHjRcwKeByHVOu+G/Cwm735X3mdAIe578j03fo/zexrxHpp38j08tCHfd2rJeR3HQ7xjUtrfErjM+/qsD16uj+7ex70B/z5G3nU+f6bCzxuHvN+BfP3Pbvl544DXiR15nxvztRZ/zoX9/P4O8XwEt7NL+/t8RMhx3b+fzb4Ffw+jnX3x/oYH9AaKP0x9nq8T/M8H+buL/DqOm71jeN4+MHCZ9/VZDrzc+/vGfZzLwM3vH+zn797nPYMb8vyMfAd5zPwMbnM4ltc9g8tzKGj8Xg7xrBm3UW/y5c+s+3t8fL3LfAVfV7fz+wr5Yhte/H2z/gFZ0hxvnnOF8Kzzyt/T8+fP//k9yM9qFzweZV09//OzCjjf8fup6OuCWmM3f4YAhv7BWObMS/fhjcT3WULcJ6zz6gFpcA5LsxBLHyGWRiGWXkIsPYRYAj432GWWfkIsTUIsoT8T6QpLTyGWBiGWQUIsA4RY+gqxpEIsAe8jdpmlLMRS6maWpC7/twKxv540/zNrfkaCPxPj+3LQcH+SP3vFtTxfo/jPaTkNtwn49/7w7Ffe89JcNpwzmd1/9o2fl+ZnS3Du52dwMK/i+xDo2/wbgKgj/swfdcS/pXj5mDeWsz6nnJwPYu47IX6bmn0qtA0v/k28UQIsZSGW3kIsqRBLXyGWAUIsg4RYGoRYegqxJEIsTUIs/YRYBgqx9BBi6SXE0ijE0keIpVmIpT6HpeDfMq9+v5yfbcFcl7/rAabhxFHw9zaqnw0zR2td/vovRT9r7/IYklP+vGfd+frF/yzUnWc2jO7kLLjP7Aj1/RT+rsyeujc+lxXKd6jn63/XhN8j+B7yCK9tGug1W0Z3tsNmi/kZC/5erv98Rt51K76XW3A7tnG5XGqt66zzkVT2kVT2VjpmOJUdrzmWyr51TOdxBbPPrat7/fWxzx3g/fmG76ohf65D/vww7/zlP/Me4hkknwP+/MxUaw4nP984xnud4xxbLGe1/zFHiXzh1UCvOY361lHh+la1nUfl1B/3rYLvzWVd/X4R958xxbJ08G8S7A8Lr/vRWixLW4h+5/IYR/woK9hT2j+WyjauWI52v/9XaJv5ImvxrAlpQ7uZhb/f2RKOpfq8WGtOPeBeE9rEnV/fTfPHguf5HQHOWa/7frNLe6hcfH4K4dvi+Y7wfP051J66N877eA61bUxnO7yf5o8Yk7i/hrgG43qEZ941WOg5zJgcjrznmAOOP9W5wNgcjlbi8OcsAd671fkBc7hUa0weRywTArCM7wLLBGKZFIBlYhdYJhFLwetRVFkmd4FlCrFMC8AytQss04hlRgCW6V1ggb87bqbF/N6aVSxfdYye6bFgG14pMYwMyJLmeHM9jBeoBzAM7sZ6mChQD2AY0431MFmgHsAwrBvrYapAPYBhSDfWw3SBegBD/e+5HhpJ42fSZxfrPZ89+d7jbPJsK7i8Ls+s0DznzHP9pr3u9anWuJxR+eYUW77qddRcyr9CHuw7r+B6Zd+S/YMH9AaKX6YfI5vXGb7W78Ds+mJHzus4bveOSWl/R+AyzyGOCm3Dy117/oTK2pHDze957G+j12UU47V8f6PYPrS3PzOnS7X68xxiKbiOq/15PuVfIQ/2XVCsbzv7oj/DA3oDxf9MbbygM3ytjcHs+vPcnNdx7Pf3lPbPDVxmfl9VaBterj//BZV1bg53RtzYz7+vwO8ZvJb7c7F9aG9/Zk6XavXnecRScB1X+/NCyr9CHuy7qFjfdvZFf4YH9AaKe9FNo0Wd4WttDGbXn+fnvI5jv7+ntH9+4DLz+6pC2/By/fm/qD/Pz+HmcQX7+d4ev2fwWu7Pxfahvf2ZOV2q1Z8XEEvBdVztz4sp/wp5sO+SYn3b2Rf9GR7QGygeRv15SWf4WhuD2fXnhTmv49jv7yntXxi4zPy+qtA2vFx/7ktlXZjDzeMK9vM9Yn7P4LXcn4vtQ3v7M3O6VKs/LyKWguu42p+XUv4V8mDfZcX6trMv+jM8oDdQPJ0abFln+Fobg9n158U5r+PY7+8p7V8cuMz8vqrQNrxcf26lsi7O4eZx5bX3O72O3zN4LffnYvvQ3v7MnC7V6s9LiKXgOq725+WUf4U8lnh6gb7t7Iv+jLyhN1C8dEx+3aCNwez689Kc13Hs9/eU9vvv7aLLvMxj8tvT9eeMyro0h5vHFezn5xn5PYPXcn8utg/t7c/M6VKt/ryMWCqFsuztzyu8/Cs5viuL9W1nX/RneEBvoPgQauOVneFrbVyxv64/L895Hcd+f09p//LAZa4QR4W24eX682oq6/Icbh5XsB/3NF3fQrvxvcblAcqyr/fmcuJr9tiLZ9n7myS+Nz+LF/iZz+otCX4uz3/mk5+FHkV8G+gZCrw27/fWXfK/d+USP9+R90xn3tpcSs/kjS2WpXou4+cLKuTBvuOL9W1nX5zL4AG9geJz6P3NzyugD4DZtWFrzus4bvGO4c9BWwOXeSxxVGgbXq6P76SytuZw87rJ2M+f37YWzO3y4GuzQR4bP88S+vm7fdXfOKqT39fzd743P3+H+vKfv0sL5ThpjsuzT8F5dvU3s3lNNnw3etfO3QefvXvn+SU6Hnn+yP42Uh71FDfQMT1ytHKO1jNH6+VpYERKKE7puEaPk3/njn/jAMzY16vujfVUaOev8wwQ11PM+1+2WsHkZ/Pus8/bsWtn6/lnnL27ta31rP/7f8cZZ5x90c6TZrXyvvNbz7zg/N2t5+/ecd7u1pPPO/vM1vZZ/w9NAiioSTEFAA==",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJzt3d2O7Lh1huF72ceDQOuX1NxKkAMjcQADhh3EPjPm3lMGpqrbkbw122SXXok8CgJUdy0uen9a1PQj/e3bH//8n7/76x/+/Ke/fPv5b9+Wf1u//fzvf/v2l//53Z/+/v//5a+/+9+/fvt5+enb7//0X4//+8tP3/77D3/8/bef5ZefNp9Sk1V+/aSaLvH6tC+7H1etHx93/fzx//jpUYsspGKEVIySijFSMU4qJkjFJKmYQiqmkoohJbCSElhJCaykBFZSAispgZWUwEpKYCUlsJISWEkJbKQENlICGymBjZTARkpgIyWwkRLYSAlspAQ2UgI7KYGdlMBOSmAnJbCTEthJCeykBHZSAjspgZ2UwEFK4CAlcJASOEgJHKQEDlICBymBg5TAQUrgICVwkhI4SQmcpAROUgInKYGTlMBJSuAkJXCSEjhJCVxICVxICVxICVxICVxICVxICVxICVxICVxICVxICVxJCVxJCVxJCVxJCVxJCVxJCVxJCVxJCVxJCVxJCbySEnglJfBKSuCVlMArKYFXUgKvpAReSQm8khJ4JSWwLKQIloWUwbKQQlgWUgrLQophWUg5LAspiGUhJbEspCiWBZXFMB6HymIWkGMJORaRYxk5FpJjKTkWk0M5OUFBOUFJOUFROUFZOUFhOUFpOUFxOUF5OUGBOUGJOUGROUGZOUGhOUGpOUGxOUG5OUHBOUHJOUHROUHZOUHhOUHpOUHxOUH5OUEBOkEJOkEROkEZOkEhOkEpOkExOkE5OkFBOkFJOkFROkFZOkFhOkFpOkFxOkF5OkGBOkGJOkGROkGZOkGhOkGpOkGxOkG5OkHBOkHJOkHROkHZOkHhOkHpOkHxOkH5OkEBO0EJO0ERO0EZO0EhO0EpO0ExO0E5O0FBO0FJO0FRO0FZO0FhO0FpO0FxO0F5O0GBO0GJO0GRO0GZO0GhO0GpO0GxO0G5O0W5O0W5O0W5O0W5O11IWawod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod6cod2cod2cod2cod2cod2cLKYsN5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4M5e4c5e4c5e4c5e4c5e58IWWxo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9ydo9xdoNxdoNxdoNxdoNxdLKQsDpS7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7C5S7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lu2TBZXKwrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9yrJ9yrJ9yrJ9yrJ9uqBSWVm2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2z1i2z1i2z1i2z1i2zxZUKhvL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9jnL9jnL9jnL9jnL9vmCSmVn2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2b5g2b5g2b5g2b5g2b5YUKkcLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNuXLNuXLNuXLNuXLNuXCyqVk2X7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7Csv2FZbt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3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTuzqV2dy61u3Op3Z1L7e5canfnUrs7l9rdudTurknt7prU7q5J7e6a1O6uvZTO4ia1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW7a1K7uya1u2tSu7smtbtrUru7JrW761K7uy61u+tSu7sutbvrL6WzuEvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uutTurkvt7rrU7q5L7e661O6uS+3uhtTubkjt7obU7m5I7e7GS+ksHlK7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7IbW7G1K7uyG1uxtSu7shtbsbUru7kNrdhdTuLqR2dyG1u4uX0lkcUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5CancXUru7kNrdhdTuLqR2dyG1uwup3V1I7e5SaneXUru7lNrdpdTuLl9KZ3FK7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u0up3V1K7e5SaneXUru7lNrdpdTuLqV2dym1u5tSu7sptbubUru7KbW7my+ls3hK7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7qbU7m5K7e6m1O5uSu3uptTubkrt7pbU7m5J7e6W1O5uSe3u1kvpLF5Su7sltbtbUru7JbW7W1K7uyW1u1tSu7sltbtbUru7JbW7W1K7uyW1u1tSu7sltbtbUru7JbW7W1K7uyW1u1vv7e7+5H88u5u3zuLH7+ats/jxu3nrLH78bt46ix+/m7fO4sfv5q2z+Om7eW939/jdvHUWP343b53Fj9+N1Fn83u7u8buROovf2909fjdSZ/F7u7vH70bqLH5vd/f43Uidxe/t7h6/G6mz+L3d3eN3I3UWv7e7e/xupM7i93Z3j9+N1Fn83u7u8buROovf2909fjdSZ/F7u7vH70bqLH5vd/f43Uidxe/t7h6/G6mz+L3d3eN3I3UWv7e7e/xupM7i93Z3j9+N1Fn83u7u8buROovf2909fjdSZ/F7u7vH70bqLH5vd/f43Uidxe/t7h6/G6mz+L3d3eN3I3UWv7e7e/xupM7i93Z3j9+N1Fn83u7u8buROovf2909fjdSZ/F7u7vH70bqLH5vd/f43Uidxe/t7h6/G6mz+L3d3eN3I3UWv7e7e/xupM7i93Z3j9+N1Fn83u7u8btROovt9d7w7vnbUTqN9+0oHcf7dpTO4307Sgfyvh2lE3nfjtKRvG9H6Uzet6N0KO/b0TqV35vgPX87WqfyeyO8529H61R+b4b3/O1oncrvDfGevx2tU/m9Kd7zt6N1Kr83xnv+drRO5ffmeM/fjtapLDXI27ejdSpLTfL27WidylKjvH07Wqey1Cxv347WqSw1zNu3o3UqS03z9u1oncpS47x9O1qnstQ8b9+O1qksNdDbt6N1KktN9PbtaJ3KUiO9fTtap7LUTG/fjtapLDXU27ejdSpLTfX27WidylJjvX07Wqey1Fxv347WqSw12Nu3o3UqS0329u1oncpSo719O1qnstRsb9+O1qksNdzbt6N1KktN9/btaJ3KUuO9fTtap7LUfG/fjtapLDXg27ejdSpLTfj27WidylIjvn07Wqey1Ixv347WqSw15Nu3o3UqS0359u1oncpSY759O1qnstScb9+O1qksNejbt6N1KktN+vbtaJ3KUqO+fTtap7LUrG/fjtapLDXs27ejdSpLTfv27Uidyqa17TOtbZ9pbftMa9tnL6lT2bS2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2mda2z7S2faa17TOtbZ9pbftMa9tnWts+09r2uda2z7W2fa617XOtbZ+/pE5l19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vnWts+19r2uda2z7W2fa617XOtbZ9rbftca9vXtLZ9TWvb17S2fU1r29deUqdy09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vY1rW1f09r2Na1tX9Pa9jWtbV/T2vZ1rW1f19r2da1tX9fa9vWX1KnctbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1da9vXtbZ9XWvb17W2fV1r29e1tn1Da9s3tLZ9Q2vbN7S2feMldSoPrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbd/Q2vYNrW3f0Nr2Da1t39Da9g2tbV9obftCa9sXWtu+0Nr2xUvqVA6tbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2faG17QutbV9obftCa9sXWtu+0Nr2hda2L7S2fam17UutbV9qbftSa9uXL6lTObW2fam17UutbV9qbftSa9uXWtu+1Nr2pda2L7W2fam17UutbV9qbftSa9uXWtu+1Nr2pda2L7W2fam17UutbV9qbftSa9uXWtu+1Nr2pda2L7W2fam17UutbV9qbftSa9uXWtu+1Nr2Zb3ts+b2e9Bayz+9qWnj9z86Y3z/yRzVDb369+388T90fN9L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a2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvTZmr43Za2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvTZmr43Za2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvTZmr43Za2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvTZmr43Za2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvTZmr43Za2P22pi9NmavjdlrY/bamL02Zq+N2Wtj9tqYvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9dmavndlrZ/bamb12Zq+d2Wtn9tqZvXZmr53Za2f22pm9Dmavg9nrYPY6mL0OZq+D2etg9jqYvQ5mr6NmTU//PdVe7Ts013eq/Ps/psq//mOq/Ns/psq//GOq/Ls/psq/+mOqfD5PqZozj6ny6TymUDdqyzymUDdqyTymUDdqxzymUDdqxTylasQ8plA3asI8plA3asA8plA3ar48plA3arw8plA3aro8plA3arg8plA3arY8plA3arQ8plA3arI8plA3arA8plA3aq48plA3aqw8plA3aqo8plA3aqg8plA3aqY8plA3aqQ8plA3aqI8plA3aqA8plA3ap48plA3apw8plA3apo8plA3apg8plA3apY8plA3apQ8plA3apI8plA3apA8plA3ao48plA3aow8plA3aoo8plA3aog8plA3aoY8plA3aoQ8plA3aoI8plA3aoA8pkg3oubHY4p0I2p8PKZIN6Kmx2OKdCNqeDymSDeiZsdjCnWj/uDzmELdQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCLBnLRQC4ayEUDuWggFw3kooFcNJCL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5KIduWhHLjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuehCLrqQiy7kogu56EIuupCLLuSiC7noQi66kIsu5KILuegiLjpexEV3CnRjp0A3dgp0Y6dAN3YKdGOnQDd2CnRjp0A3dgp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6gZx0Z1C3SAuulOoG8RFdwp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6gZx0Z1C3SAuulOoG8RFdwp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6gZx0Z1C3SAuulOoG8RFdwp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6gZx0Z1C3SAuulOoG8RFdwp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6gZx0Z1C3SAuulOoG8RFdwp1g7joTqFuEBfdKdQN4qI7hbpBXHSnUDeIi+4U6YYhFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1C5c1Nqfp+punFJ1N06puhunVN2NU6ruxilVd+OQuhDOU6r8O4zw31ORvUqVf4fHVPl3eEyVf4eHlNem90tqlqmy82mv31PpXqXKzh9TZeePqfLndUyVP69jqvx5HVP1z2utr1TPKlV2/pSqTe+YqrtxSpXdOKbKbhxTZTeOqfqpPKXqp/KQqsVstPl13Ize/2hH5neu/Lu/kSv/9m/kyr//G7nyJ3AjVz6fN3Llz+5Grvzp3ciVT+mNXPmcnnO1ot3Iwb7UknYjB/tSa9qNHOxLLWo3crAvtardyMG+1LJ2Iwf7UuvajRzsSy1sN3KwL7Wy3cjBvtTSdiMH+1Jr240c7EstbjdysC+1ut3Iwb7U8nYjB/tS69uNHOxLLXA3crAvtcLdyMG+1BJ3Iwf7UmvcjRzsSy1yN3KwL7XK3cjBvtQydyMH+1Lr3I0c7EstdDdysC+10t3Iwb7UUncjB/tSa92NHOxLLXY3crAvtdrdyMG+1HJ3Iwf7Un/VeCMH+1J/2XgjB/tSf914Iwf7UgvljRzsS62UN3KsL63+0vFGjvWl1TJ6I8f60modvZFjfWm1kN7Isb60Wklv5GBfaim9kYN9qbX0Rg72pRbTGznYl9pab+RgX+qvIW/kYF+g7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruvHBTW98576/vXJ/fufrncMxduOk5V/8czrn653DO1T+Hc67+OZxz9XN7ztXP7TlXP7fnHOzLhZsecxdues7Bvly46TkH+3Lhpucc7MuFm55zsC8XbnrOsb6sCzc951hf1oWbnnOsL+vCTc851pd14abnHOvLunDTcw725cJNzznYlws3PedgXy7c9JyDfblw03MO9uXCTc852JcLNz3nYF8u3PScg325cNNzDvblwk3POdiXCzc952BfLtz0nIN9uXDTcw725cJNzznYlws3PedgXy7c9JyDfblw03MO9uXCTc852JcLNz3nYF8u3PScg325cNNzDvblwk3POdiXCzc952BfLtz0nIN9uXDTcw725cJNzznYlws3PedgXy7c9JyDfblw03MO9uXCTc852JcLNz3nYF8u3PScg325cNNzDvblwk3POdiXi+9izznYF+i7C/rugr67oO8u6Lvr8rtY/8pFjCp35eyn3NV7mVPu6r3MKXf1XuaUu3ovc8pdvZc55C6/iz3lrt7LnHJX72VOOdiXy+9iTznYl8vvYk852JfL72JPOdSXeF1+F3vKob7sHOrLzqG+7Bzqy86hvuwc6svOob7sHOrLzsG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XH4Xe8rBvlx+F3vKwb5cfhd7ysG+XP7eg1MO9uXy9x6ccrAvl7/34JSDfbn8vQenHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOuLQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3Hfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux367oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ou4v5br6Y7+4c6svOob7sHOrLzqG+7Bzqy86hvuwc6svOob7sHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnYF+a7Owf7wnx352BfmO/uHOwL892dg31hvrtzsC/Md3cO9oX57s7BvjDf3TnWF4O+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9/12k33v2bb77n9bybrOxfxnSt/Djdy5c/hRq78OdzIlT+HG7ny53AjV/4cbuTK5/ZGrnxuz7naTW/kYF9qN72Rg32p3fRGDvaldtMbOdiX2k1v5GBfaje9kYN9qd30Rg72pXbTGznYl9pNb+RgX2o3vZGDfand9EYO9qV20xs52JfaTW/kYF9qN72Rg32p3fRGDvaldtMbOdiX2k1v5GBfaje9kYN9qd30Rg72pXbTGznWl1a76Y0c60ur3fRGjvWl1W56I8f60mo3vZFjfWm1m97Iwb7UbnojB/ty4ZgrXl//PrbS/vO/j7ULxzzn6n9vPOfqf28852pnOOZqVwx/td9z4b/8ff6SK5+/G7ny+buRK39+N3Llz+9Grvz53ciVP78bufLndyNXPn/nXO2KN3KwL7Ur3sjBvtSueCMH+1K74o0c7EvtijdysC+1K97Iwb7UrngjB/tSu+KNHOxL7Yo3crAv9XejN3KwL/V3ozdysC+1f97Iwb7U/nkjB/tS++eN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"
    ],
    "fileMap": {
      "1": {
        "source": "contract PrivateCounter {\n    use dep::aztec::{\n        context::{Context},\n            note::{\n                note_header::NoteHeader,\n                utils as note_utils,\n            },\n            state_vars::map::Map,\n    };\n    use dep::value_note::{\n        balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n\n    struct Storage {\n        counts: Map<EasyPrivateUint>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counts: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor(initial_count: u120, owner: Field) {\n        let counts = storage.counts;\n        counts.at(owner).add(initial_count, owner);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: Field)  {\n        let counts = storage.counts;\n        counts.at(owner).add(1, owner);\n    }\n\n    unconstrained fn get_counter(owner: Field) -> Field {\n        let counts = storage.counts;\n        balance_utils::get_balance(counts.at(owner).set)\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: Field,\n        nonce: Field,\n        storage_slot: Field,\n        preimage: [Field; VALUE_NOTE_LEN],\n    ) -> [Field; 4] {\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/Users/philogy/Documents/Aztec/second_token/src/contracts/src/main"
      },
      "5": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "17": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\nfn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\nfn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar"
      },
      "18": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\nfn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul"
      },
      "35": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/abi"
      },
      "37": {
        "source": "use dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\nfn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0]\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/address"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 48),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 64),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 80),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 96),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 100),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 104),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 106),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 108),\n                encrypted_log_preimages_length: fields[110],\n                unencrypted_log_preimages_length: fields[111],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[112],\n                    nullifier_tree_root : fields[113],\n                    contract_tree_root : fields[114],\n                    l1_to_l2_messages_tree_root : fields[115],\n                    blocks_tree_root : fields[116],\n                    public_data_tree_root: fields[117],\n                    global_variables_hash: fields[118],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[119], fields[120]),\n                    constructor_vk_hash : fields[121],\n                    function_tree_root : fields[122],\n                    contract_address_salt : fields[123],\n                    portal_contract_address : fields[124],\n                },\n                chain_id: fields[125],\n                version: fields[126],\n            },\n            is_execution_request: fields[127] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/context"
      },
      "42": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/log"
      },
      "47": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/lifecycle"
      },
      "48": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n    from_public: bool,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    // Check the note hash via oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, note);\n    let exists = oracle::notes::check_note_hash_exists(header.nonce, inner_note_hash);\n    assert(exists, \"Note hash does not exist.\");\n\n    let mut note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n    if from_public {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n        // Should remove this once public kernel applies nonces.\n        note_hash_for_read_request = compute_siloed_note_hash(note_interface, note);\n    }\n    context.push_read_request(note_hash_for_read_request);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n        };\n    };\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/note_getter"
      },
      "50": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/note_hash"
      },
      "53": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{Select, Sort};\nuse crate::types::vec::BoundedVec;\n\n// docs:start:NoteViewerOptions\nstruct NoteViewerOptions<Note, N> {\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n    limit: u32,\n    offset: u32,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, N> NoteViewerOptions<Note, N> {\n    fn new() -> NoteViewerOptions<Note, N> {\n        NoteViewerOptions {\n            selects: BoundedVec::new(Option::none()),\n            sorts: BoundedVec::new(Option::none()),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n        }\n    }\n\n   fn select(&mut self, field_index: u8, value: Field) -> Self {\n        self.selects.push(Option::some(Select::new(field_index, value)));\n        *self\n    }\n\n    fn sort(&mut self, field_index: u8, order: u2) -> Self {\n        self.sorts.push(Option::some(Sort::new(field_index, order)));\n        *self\n    }\n\n    fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        self.limit = limit;\n        *self\n    }\n\n    fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/note_viewer_options"
      },
      "54": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/utils"
      },
      "61": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/get_public_key"
      },
      "62": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(\n    _owner: Point,\n) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\nfn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/get_secret_key"
      },
      "63": {
        "source": "\n\n#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/rand"
      },
      "66": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(checkNoteHashExists)]\nfn check_note_hash_exists_oracle<N>(\n    _nonce: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn check_note_hash_exists(\n    nonce: Field,\n    inner_note_hash: Field,\n) -> bool {\n    check_note_hash_exists_oracle(nonce, inner_note_hash) == 1\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_some.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let header = NoteHeader { contract_address, nonce, storage_slot };\n            let is_some = fields[read_offset + 1] as bool;\n            if is_some {\n                let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n                let mut note = deserialize(preimage);\n                set_header(&mut note, header);\n                placeholder_opt_notes[i] = Option::some(note);\n            }\n        };\n    };\n    placeholder_opt_notes\n}\n\nunconstrained fn is_nullifier_emitted(nullifier: Field) -> bool {\n    // TODO\n    nullifier == 0\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/notes"
      },
      "68": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_message: T)  -> Field {}\n\nunconstrained fn emit_unencrypted_log<T>(message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(message), 0]\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/logs"
      },
      "75": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = dep::std::hash::pedersen([self.storage_slot, key])[0];\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/state_vars/map"
      },
      "77": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::constants_gen::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{ensure_note_hash_exists, get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    fn insert(self, note: &mut Note) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // docs:start:assert_contains_and_remove\n    fn assert_contains_and_remove(self, note: &mut Note, nonce: Field) {\n        // Initialize header of note. Must be done before computing note hashes as it initializes the:\n        // - storage slot (used in inner note hash)\n        // - the contract address (used in siloed note hash)\n        // - and the nonce (used in the unique siloed note hash)\n        let context = self.context.private.unwrap();\n        let set_header = self.note_interface.set_header;\n        let note_header = NoteHeader{\n            contract_address: context.this_address(),\n            storage_slot: self.storage_slot,\n            nonce\n        };\n        set_header(note, note_header);\n\n        ensure_note_hash_exists(\n            context,\n            self.note_interface,\n            *note,\n            false,\n        );\n\n        destroy_note(\n            context,\n            *note,\n            self.note_interface,\n        );\n    }\n    // docs:end:assert_contains_and_remove\n\n    // docs:start:assert_contains_and_remove_publicly_created\n    // NOTE: this function should ONLY be used for PUBLICLY-CREATED note hashes!\n    // WARNING: function will be deprecated/removed eventually once public kernel applies nonces.\n    fn assert_contains_and_remove_publicly_created(self, note: &mut Note) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n        // Should be real nonce (once public kernel applies nonces).\n        let nonce = 0;\n        let context = self.context.private.unwrap();\n        let set_header = self.note_interface.set_header;\n        let mut note_header = NoteHeader{\n            contract_address: context.this_address(),\n            storage_slot: self.storage_slot,\n            nonce\n        };\n        set_header(note, note_header);\n\n        ensure_note_hash_exists(\n            context,\n            self.note_interface,\n            *note,\n            true,\n        );\n\n        // Set the nonce to nonzero so that the nullifier is treated as persistable\n        // (non-transient) and so the private kernel does not attempt to match it to\n        // a pending noteHash/commitment and squash them.\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): remove\n        // this hack once public kernel injects nonces.\n        note_header.nonce = 1;\n        set_header(note, note_header);\n\n        destroy_note(\n            context,\n            *note,\n            self.note_interface,\n        );\n    }\n    // docs:end:assert_contains_and_remove_publicly_created\n\n    // docs:start:remove\n    fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/state_vars/set"
      },
      "82": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/types/vec"
      },
      "88": {
        "source": "fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/utils"
      },
      "89": {
        "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/value-note/src/balance_utils"
      },
      "92": {
        "source": "use dep::aztec::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse dep::aztec::oracle::{\n    rand::rand,\n    get_secret_key::get_secret_key,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    fn deserialize(preimage: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: preimage[0],\n            owner: preimage[1],\n            randomness: preimage[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        dep::std::hash::pedersen([\n            self.value, \n            self.owner,\n            self.randomness,\n        ])[0]\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        dep::std::hash::pedersen([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ])[0]\n    }\n\n    // docs:end:nullifier\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialize(preimage: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(preimage)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/value-note/src/value_note"
      },
      "93": {
        "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext, Context},\n    log::emit_encrypted_log,\n    note::note_getter_options::NoteGetterOptions,\n    oracle::get_public_key::get_public_key,\n    state_vars::set::Set,\n    types::point::Point,\n};\nuse dep::std::option::Option;\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    fn add(self, addend: u120, owner: Field) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note);\n        // docs:end:insert\n\n        // Emit the newly created encrypted note preimages via oracle calls.\n        let owner_key = get_public_key(owner);\n        let context = self.context.private.unwrap();\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            self.set.storage_slot,\n            owner_key,\n            addend_note.serialize(),\n        );\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    fn sub(self, subtrahend: u120, owner: Field) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner == owner);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note);\n\n        // Emit the newly created encrypted note preimages via oracle calls.\n        let mut encrypted_data = [0; VALUE_NOTE_LEN];\n        if result_value != 0 {\n            encrypted_data = result_note.serialize();\n        };\n\n        let owner_key = get_public_key(owner);\n\n        let context = self.context.private.unwrap();\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            self.set.storage_slot,\n            owner_key,\n            encrypted_data,\n        );\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-nrmaster/easy-private-state/src/easy_private_state"
      }
    }
  }
}